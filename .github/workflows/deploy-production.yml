name: Full Stack CI/CD Pipeline

on:
  push:
    branches:
      - deploy-production

jobs:
  build_push_backend:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Cache Docker layers
        uses: actions/cache@v3
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-backend_${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-backend-

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_TOKEN }}

      - name: Build and push backend
        uses: docker/build-push-action@v4
        with:
          context: ./backend
          file: ./backend/Dockerfile.prod
          push: true
          tags: ${{ secrets.DOCKER_HUB_USERNAME }}/server_image:tts_backend_${{ github.sha }}
          platforms: linux/amd64
          cache-from: type=local,src=/tmp/.buildx-cache
          cache-to: type=local,dest=/tmp/.buildx-cache-new

      - name: Move cache
        run: |
          rm -rf /tmp/.buildx-cache
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache

  build_push_frontend:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Cache Docker layers
        uses: actions/cache@v3
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-frontend_${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-frontend-

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_TOKEN }}

      - name: Build and push frontend
        uses: docker/build-push-action@v4
        with:
          context: ./frontend
          file: ./frontend/Dockerfile.prod
          push: true
          tags: ${{ secrets.DOCKER_HUB_USERNAME }}/server_image:tts_frontend_${{ github.sha }}
          platforms: linux/amd64
          cache-from: type=local,src=/tmp/.buildx-cache
          cache-to: type=local,dest=/tmp/.buildx-cache-new
          build-args: |
            VITE_BACKEND_SERVER=${{ secrets.VITE_BACKEND_SERVER }}

      - name: Move cache
        run: |
          rm -rf /tmp/.buildx-cache
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache

  build_push_gateway:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Cache Docker layers
        uses: actions/cache@v3
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-gateway_${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-gateway-

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_TOKEN }}

      - name: Build and push gateway
        uses: docker/build-push-action@v4
        with:
          context: ./nginx_gateway
          file: ./nginx_gateway/Dockerfile
          push: true
          tags: ${{ secrets.DOCKER_HUB_USERNAME }}/server_image:tts_gateway_${{ github.sha }}
          platforms: linux/amd64
          cache-from: type=local,src=/tmp/.buildx-cache
          cache-to: type=local,dest=/tmp/.buildx-cache-new

      - name: Move cache
        run: |
          rm -rf /tmp/.buildx-cache
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache

  deploy_production:
    needs:
      - build_push_backend
      - build_push_frontend
      - build_push_gateway
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Deploy full stack to VPS
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SERVER_HOST_TTS }}
          username: ${{ secrets.SERVER_USER_TTS }}
          key: ${{ secrets.SSH_PRIVATE_KEY_TTS }}
          port: ${{ secrets.SERVER_PORT_TTS }}
          script: |
            set -e
            set -o pipefail

            cd /workspace/tts || { echo "‚ùå Failed to change directory"; exit 1; }

            HEALTH_CHECK_TIMEOUT=65
            STACK_NAME=tts
            
            BACKEND_SERVICE=tts_backend
            FRONTEND_SERVICE=tts_frontend
            GATEWAY_SERVICE=tts_gateway
            
            BACKEND_EXPECT_TAG=${{ secrets.DOCKER_HUB_USERNAME }}/server_image:tts_backend_${{ github.sha }}
            FRONTEND_EXPECT_TAG=${{ secrets.DOCKER_HUB_USERNAME }}/server_image:tts_frontend_${{ github.sha }}
            GATEWAY_EXPECT_TAG=${{ secrets.DOCKER_HUB_USERNAME }}/server_image:tts_gateway_${{ github.sha }}

            # Git operations
            git fetch origin deploy-production || { echo "‚ùå Failed to fetch from origin"; exit 1; }
            git add .
            git checkout -f || { echo "‚ùå Failed to force checkout"; exit 1; }
            git checkout deploy-production || git checkout -b deploy-production origin/deploy-production || { echo "‚ùå Failed to checkout deploy-production branch"; exit 1; }
            git reset --hard origin/deploy-production || { echo "‚ùå Failed to reset to latest deploy-production"; exit 1; }

            # Docker login
            echo "üîê Logging in to Docker Hub..."
            echo "${{ secrets.DOCKER_HUB_TOKEN }}" | docker login -u ${{ secrets.DOCKER_HUB_USERNAME }} --password-stdin || { echo "‚ùå Failed to login to Docker Hub"; exit 1; }

            # Pull images with retry and timeout
            echo "‚¨áÔ∏è Pulling images..."
            if ! timeout 300 docker pull "$BACKEND_EXPECT_TAG"; then echo "‚ùå Failed to pull backend"; exit 1; fi
            if ! timeout 300 docker pull "$FRONTEND_EXPECT_TAG"; then echo "‚ùå Failed to pull frontend"; exit 1; fi
            if ! timeout 300 docker pull "$GATEWAY_EXPECT_TAG"; then echo "‚ùå Failed to pull gateway"; exit 1; fi

            # Prepare docker-compose file
            echo "üõ† Creating temporary docker-compose.deploy.yml..."
            cp docker-compose.prod.yml docker-compose.deploy.yml || { echo "‚ùå Failed to copy docker-compose"; exit 1; }

            echo "üîÅ Updating image tags with SHA..."
            sed -i "s|image: .*/server_image:tts_backend.*|image: ${BACKEND_EXPECT_TAG}|g" docker-compose.deploy.yml
            sed -i "s|image: .*/server_image:tts_frontend.*|image: ${FRONTEND_EXPECT_TAG}|g" docker-compose.deploy.yml
            sed -i "s|image: .*/server_image:tts_gateway.*|image: ${GATEWAY_EXPECT_TAG}|g" docker-compose.deploy.yml

            # Initialize Docker Swarm if needed
            docker swarm init --advertise-addr 127.0.0.1 || true

            # Deploy stack
            echo "üöÄ Deploying full stack..."
            docker stack deploy --with-registry-auth --compose-file docker-compose.deploy.yml "$STACK_NAME" || { echo "‚ùå Failed to deploy stack"; exit 1; }

            sleep 10

            # --- FUNCTION: CHECK SERVICE HEALTH ---
            check_service_health() {
              local SERVICE_NAME=$1
              local EXPECT_IMAGE_TAG=$2

              echo "‚è≥ Checking health for service '$SERVICE_NAME'..."
              HEALTH_CHECK_START=$(date +%s)

              while true; do
                CURRENT_TIME=$(date +%s)
                ELAPSED=$((CURRENT_TIME - HEALTH_CHECK_START))

                if (( ELAPSED > HEALTH_CHECK_TIMEOUT )); then
                  echo "‚ùå Timeout waiting for health checks after ${ELAPSED}s for $SERVICE_NAME."
                  docker service ps "$SERVICE_NAME" --no-trunc
                  return 1
                fi

                service_tasks=$(docker service ps "$SERVICE_NAME" --filter desired-state=running --format '{{.ID}}\t{{.Name}}\t{{.Image}}\t{{.CurrentState}}' --no-trunc)
                unhealthy_count=0
                total_new_count=0
                old_healthy_count=0

                if [ -n "$service_tasks" ]; then
                  while IFS=$'\t' read -r task_id task_name task_image task_state; do
                    [ -z "$task_id" ] && continue
                    clean_task_image=$(echo "$task_image" | cut -d'@' -f1)

                    if [ "$clean_task_image" = "$EXPECT_IMAGE_TAG" ]; then
                      total_new_count=$((total_new_count + 1))
                      container_id=$(docker ps --filter "label=com.docker.swarm.task.id=${task_id}" --format '{{.ID}}' | head -n1)

                      if [ -n "$container_id" ]; then
                        health_status=$(docker inspect "$container_id" --format '{{if .State.Health}}{{.State.Health.Status}}{{else}}no-healthcheck{{end}}' 2>/dev/null)
                        # L∆∞u √Ω: Gateway image g·ªëc Alpine/Nginx c√≥ th·ªÉ kh√¥ng c√≥ HEALTHCHECK trong Dockerfile n·∫øu ta kh√¥ng th√™m, 
                        # nh∆∞ng ·ªü ƒë√¢y ta ƒë√£ th√™m healthcheck v√†o docker-compose.yml n√™n state v·∫´n s·∫Ω l√† healthy/unhealthy.
                        
                        if [ "$health_status" != "healthy" ] && [ "$health_status" != "no-healthcheck" ]; then
                          unhealthy_count=$((unhealthy_count + 1))
                          echo "‚ö†Ô∏è New container $task_name: $health_status ($task_state) [${ELAPSED}s elapsed]"
                        else
                          echo "‚úÖ New container $task_name: $health_status [${ELAPSED}s elapsed]"
                        fi
                      else
                        unhealthy_count=$((unhealthy_count + 1))
                        echo "‚è≥ Waiting for new container of task ${task_id:0:12} to start... [${ELAPSED}s elapsed]"
                      fi
                    else
                      # Old container handling
                      container_id=$(docker ps --filter "label=com.docker.swarm.task.id=${task_id}" --format '{{.ID}}' | head -n1)
                      if [ -n "$container_id" ]; then
                        health_status=$(docker inspect "$container_id" --format '{{if .State.Health}}{{.State.Health.Status}}{{else}}no-healthcheck{{end}}' 2>/dev/null)
                        if [ "$health_status" = "healthy" ] || [ "$health_status" = "no-healthcheck" ]; then
                          old_healthy_count=$((old_healthy_count + 1))
                        fi
                      fi
                    fi
                  done <<< "$service_tasks"
                fi

                if [ "$total_new_count" -gt 0 ] && [ "$unhealthy_count" -eq 0 ]; then
                  echo "‚úÖ All $total_new_count new containers of service '$SERVICE_NAME' are healthy."
                  if [ "$old_healthy_count" -gt 0 ]; then
                    echo "üîÑ $old_healthy_count old containers will be stopped by Docker Swarm."
                  fi
                  break
                elif [ "$total_new_count" -eq 0 ]; then
                  echo "‚è≥ No new tasks with new image detected yet for $SERVICE_NAME, waiting... [${ELAPSED}s elapsed]"
                else
                  echo "‚ö†Ô∏è $unhealthy_count/$total_new_count new containers are not yet healthy for $SERVICE_NAME, waiting... [${ELAPSED}s elapsed]"
                  if [ "$old_healthy_count" -gt 0 ]; then
                    echo "‚ÑπÔ∏è $old_healthy_count old containers are still serving traffic"
                  fi
                fi

                sleep 3
              done

              # Wait for correct replicas scaling
              echo "‚è≥ Waiting for service '$SERVICE_NAME' to have correct replicas..."
              while ! docker service ls --filter name="$SERVICE_NAME" --format '{{.Replicas}}' | grep -qE '^([0-9]+)/\1$'; do
                CURRENT_TIME=$(date +%s)
                ELAPSED=$((CURRENT_TIME - HEALTH_CHECK_START))
                if (( ELAPSED > HEALTH_CHECK_TIMEOUT )); then
                  echo "‚ùå Timeout waiting for service scaling after ${ELAPSED}s for $SERVICE_NAME."
                  docker service ps "$SERVICE_NAME" --no-trunc
                  return 1
                fi
                sleep 2
              done
              echo "‚úÖ Service '$SERVICE_NAME' has correct replicas."
              
              # Rollback Detection
              echo "‚è≥ Checking for rollback on $SERVICE_NAME..."
              sleep 3
              DEPLOYED_IMAGE_TAG=$(docker service ps "$SERVICE_NAME" --no-trunc --filter desired-state=running --format '{{.Image}}' 2>/dev/null | head -n1 | cut -d'@' -f1 || echo "not_found")

              if [[ "$DEPLOYED_IMAGE_TAG" != "$EXPECT_IMAGE_TAG" ]]; then
                echo "‚ùå Rollback detected for $SERVICE_NAME: running '$DEPLOYED_IMAGE_TAG' instead of '$EXPECT_IMAGE_TAG'"
                docker service ps "$SERVICE_NAME" --no-trunc || true
                docker service inspect "$SERVICE_NAME" --pretty || true
                return 1
              fi

              return 0
            }
            # --- END FUNCTION ---

            # Check Services Health
            echo "üîç Checking backend service health..."
            if ! check_service_health "$BACKEND_SERVICE" "$BACKEND_EXPECT_TAG"; then
              echo "‚ùå Backend health check failed"
              exit 1
            fi

            echo "üîç Checking frontend service health..."
            if ! check_service_health "$FRONTEND_SERVICE" "$FRONTEND_EXPECT_TAG"; then
              echo "‚ùå Frontend health check failed"
              exit 1
            fi
            
            echo "üîç Checking gateway service health..."
            if ! check_service_health "$GATEWAY_SERVICE" "$GATEWAY_EXPECT_TAG"; then
              echo "‚ùå Gateway health check failed"
              exit 1
            fi

            # Clean up
            echo "üßπ Cleaning up Docker..."
            docker system prune -a -f
            
            echo "üîß Git cleanup for next deployment"
            git reset --hard HEAD || true
            git clean -fd || true
            rm -f docker-compose.deploy.yml || true

            echo "‚úÖ Successfully deployed full stack!"

      - name: Notify GitHub on success
        if: success()
        uses: actions/github-script@v6
        with:
          script: |
            try {
              github.rest.repos.createCommitComment({
                owner: '${{ github.repository_owner }}',
                repo: '${{ github.event.repository.name }}',
                commit_sha: '${{ github.sha }}',
                body: '‚úÖ Full stack deployment (Backend + Frontend + Gateway) successful!\n[Workflow](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})'
              });
            } catch (error) { console.log('Failed to create commit comment:', error.message); }

      - name: Notify Google Chat on success
        if: success()
        run: |
          curl -X POST -H 'Content-Type: application/json' \
            -d '{"text": "‚úÖ *[TTS Full Stack] Deployment successful !*\n- Workflow: <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Details>"}' \
            '${{ secrets.GOOGLE_CHAT_WEBHOOK }}'

      - name: Notify GitHub on failure
        if: failure()
        uses: actions/github-script@v6
        with:
          script: |
            try {
              github.rest.repos.createCommitComment({
                owner: '${{ github.repository_owner }}',
                repo: '${{ github.event.repository.name }}',
                commit_sha: '${{ github.sha }}',
                body: '‚ùå Full stack deployment failed! Please check the logs for details.\n[Workflow](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})'
              });
            } catch (error) { console.log('Failed to create commit comment:', error.message); }

      - name: Notify Google Chat on failure
        if: failure()
        run: |
          curl -X POST -H 'Content-Type: application/json' \
            -d '{"text": "‚ùå *[TTS Full Stack] Deployment failed !*\n- Workflow: <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Details>"}' \
            '${{ secrets.GOOGLE_CHAT_WEBHOOK }}'