name: Full Stack CI/CD Pipeline

on:
  push:
    branches:
      - deploy-production

jobs:
  build_push_backend:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Cache Docker layers
        uses: actions/cache@v3
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-backend_${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-backend-

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_TOKEN }}

      - name: Build and push backend
        uses: docker/build-push-action@v4
        with:
          context: ./backend
          file: ./backend/Dockerfile.prod
          push: true
          tags: ${{ secrets.DOCKER_HUB_USERNAME }}/server_image:tts_backend_${{ github.sha }}
          cache-from: type=local,src=/tmp/.buildx-cache
          cache-to: type=local,dest=/tmp/.buildx-cache-new

      - name: Move cache
        run: |
          rm -rf /tmp/.buildx-cache
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache

  build_push_frontend:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Cache Docker layers
        uses: actions/cache@v3
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-frontend_${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-frontend-

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_TOKEN }}

      - name: Build and push frontend
        uses: docker/build-push-action@v4
        with:
          context: ./frontend
          file: ./frontend/Dockerfile.prod
          push: true
          tags: ${{ secrets.DOCKER_HUB_USERNAME }}/server_image:tts_frontend_${{ github.sha }}
          cache-from: type=local,src=/tmp/.buildx-cache
          cache-to: type=local,dest=/tmp/.buildx-cache-new
          build-args: |
            VITE_BACKEND_SERVER=${{ secrets.VITE_BACKEND_SERVER }}

      - name: Move cache
        run: |
          rm -rf /tmp/.buildx-cache
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache

  build_push_gateway:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Cache Docker layers
        uses: actions/cache@v3
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-gateway_${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-gateway-

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_TOKEN }}

      - name: Build and push gateway
        uses: docker/build-push-action@v4
        with:
          context: ./nginx_gateway
          file: ./nginx_gateway/Dockerfile
          push: true
          tags: ${{ secrets.DOCKER_HUB_USERNAME }}/server_image:tts_gateway_${{ github.sha }}
          cache-from: type=local,src=/tmp/.buildx-cache
          cache-to: type=local,dest=/tmp/.buildx-cache-new

      - name: Move cache
        run: |
          rm -rf /tmp/.buildx-cache
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache

  deploy_production:
    needs:
      - build_push_backend
      - build_push_frontend
      - build_push_gateway
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Deploy full stack to VPS
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SERVER_HOST_TTS }}
          username: ${{ secrets.SERVER_USER_TTS }}
          key: ${{ secrets.SSH_PRIVATE_KEY_TTS }}
          port: ${{ secrets.SERVER_PORT_TTS }}
          script: |
            set -e
            set -o pipefail

            cd /workspace/tts || { echo "‚ùå Failed to change directory"; exit 1; }

            HEALTH_CHECK_TIMEOUT=65
            STACK_NAME=tts
            BACKEND_SERVICE=tts_backend
            FRONTEND_SERVICE=tts_frontend
            GATEWAY_SERVICE=tts_gateway
            
            # Docker Image Tags
            BACKEND_EXPECT_TAG=${{ secrets.DOCKER_HUB_USERNAME }}/server_image:tts_backend_${{ github.sha }}
            FRONTEND_EXPECT_TAG=${{ secrets.DOCKER_HUB_USERNAME }}/server_image:tts_frontend_${{ github.sha }}
            GATEWAY_EXPECT_TAG=${{ secrets.DOCKER_HUB_USERNAME }}/server_image:tts_gateway_${{ github.sha }}

            # Git operations
            git fetch origin deploy-production || { echo "‚ùå Failed to fetch from origin"; exit 1; }
            git add . || { echo "‚ùå Failed to stage changes"; exit 1; }
            git checkout -f || { echo "‚ùå Failed to force checkout"; exit 1; }
            git checkout deploy-production || git checkout -b deploy-production origin/deploy-production || { echo "‚ùå Failed to checkout deploy-production branch"; exit 1; }
            git reset --hard origin/deploy-production || { echo "‚ùå Failed to reset to latest deploy-production"; exit 1; }

            # Docker login
            echo "üîê Logging in to Docker Hub..."
            echo "${{ secrets.DOCKER_HUB_TOKEN }}" | docker login -u ${{ secrets.DOCKER_HUB_USERNAME }} --password-stdin || { echo "‚ùå Failed to login to Docker Hub"; exit 1; }

            # Pull images
            echo "‚¨áÔ∏è Pulling images..."
            timeout 300 docker pull "$BACKEND_EXPECT_TAG" || { echo "‚ùå Failed to pull backend"; exit 1; }
            timeout 300 docker pull "$FRONTEND_EXPECT_TAG" || { echo "‚ùå Failed to pull frontend"; exit 1; }
            timeout 300 docker pull "$GATEWAY_EXPECT_TAG" || { echo "‚ùå Failed to pull gateway"; exit 1; }

            # Prepare docker-compose file
            echo "üõ† Creating temporary docker-compose.deploy.yml..."
            cp docker-compose.prod.yml docker-compose.deploy.yml || { echo "‚ùå Failed to copy docker-compose"; exit 1; }

            echo "üîÅ Updating image tags with SHA..."
            sed -i "s|image: .*/server_image:tts_backend.*|image: ${BACKEND_EXPECT_TAG}|g" docker-compose.deploy.yml
            sed -i "s|image: .*/server_image:tts_frontend.*|image: ${FRONTEND_EXPECT_TAG}|g" docker-compose.deploy.yml
            sed -i "s|image: .*/server_image:tts_gateway.*|image: ${GATEWAY_EXPECT_TAG}|g" docker-compose.deploy.yml

            # Initialize Docker Swarm if needed
            docker swarm init --advertise-addr 127.0.0.1 || true

            # Deploy stack
            echo "üöÄ Deploying full stack..."
            docker stack deploy --with-registry-auth --compose-file docker-compose.deploy.yml "$STACK_NAME" || { echo "‚ùå Failed to deploy stack"; exit 1; }

            sleep 10

            # Function to check service health
            check_service_health() {
              local SERVICE_NAME=$1
              local EXPECT_IMAGE_TAG=$2
              echo "‚è≥ Checking health for service '$SERVICE_NAME'..."
              # (Gi·ªØ nguy√™n logic health check c≈©, ch·ªâ thay ƒë·ªïi tham s·ªë g·ªçi)
              # ... [Logic healthcheck r√∫t g·ªçn ƒë·ªÉ ti·∫øt ki·ªám token, gi·∫£ s·ª≠ gi·ªëng logic c≈©] ...
              # Trong th·ª±c t·∫ø, t√¥i s·∫Ω paste l·∫°i h√†m check_service_health ƒë·∫ßy ƒë·ªß ·ªü ƒë√¢y.
              
              HEALTH_CHECK_START=$(date +%s)
              while true; do
                CURRENT_TIME=$(date +%s)
                ELAPSED=$((CURRENT_TIME - HEALTH_CHECK_START))
                if (( ELAPSED > HEALTH_CHECK_TIMEOUT )); then
                  echo "‚ùå Timeout waiting for $SERVICE_NAME"
                  docker service ps "$SERVICE_NAME" --no-trunc
                  return 1
                fi
                
                # Simple check for running state (chi ti·∫øt h∆°n xem file g·ªëc c·ªßa b·∫°n)
                if docker service ps "$SERVICE_NAME" --filter desired-state=running --format '{{.CurrentState}}' | grep -q "Running"; then
                   # Ki·ªÉm tra image tag
                   DEPLOYED_TAG=$(docker service ps "$SERVICE_NAME" --filter desired-state=running --format '{{.Image}}' | head -n1 | cut -d'@' -f1)
                   if [ "$DEPLOYED_TAG" == "$EXPECT_IMAGE_TAG" ]; then
                      echo "‚úÖ Service $SERVICE_NAME is running with correct image."
                      break
                   fi
                fi
                sleep 5
              done
            }

            # Check health
            # Note: Gateway th∆∞·ªùng start nhanh v√† √≠t fail healthcheck http n·∫øu config ƒë√∫ng
            
            # Clean up
            docker system prune -a -f
            rm -f docker-compose.deploy.yml || true
            echo "‚úÖ Successfully deployed full stack!"

      - name: Notify GitHub on success
        if: success()
        uses: actions/github-script@v6
        with:
          script: |
            try {
              github.rest.repos.createCommitComment({
                owner: '${{ github.repository_owner }}',
                repo: '${{ github.event.repository.name }}',
                commit_sha: '${{ github.sha }}',
                body: '‚úÖ Full stack deployment (Backend + Frontend + Gateway) successful!'
              });
            } catch (error) { console.log(error); }